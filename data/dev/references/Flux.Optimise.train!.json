{"attributes":{"kind":"function","backlinks":[{"tag":"sourcefile","title":"Flux/src/optimise/train.jl","docid":"sourcefiles/Flux/src/optimise/train.jl"},{"tag":"sourcefile","title":"Flux/src/optimise/Optimise.jl","docid":"sourcefiles/Flux/src/optimise/Optimise.jl"}],"methods":[{"line":104,"file":"/home/runner/.julia/packages/Flux/7nTyc/src/optimise/train.jl","method_id":"Flux.Optimise.train!_1","symbol_id":"Flux.Optimise.train!","signature":"train!(loss, ps, data, opt; cb)"}],"name":"train!","title":"train!","symbol_id":"Flux.Optimise.train!","public":true,"module_id":"Flux.Optimise"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["train!(loss, params, data, opt; cb)\n"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["train!"],"type":"node"}," uses a ",{"attributes":{},"tag":"code","children":["loss"],"type":"node"}," function and training ",{"attributes":{},"tag":"code","children":["data"],"type":"node"}," to improve the",{"attributes":{},"tag":"br","children":[],"type":"node"},{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":["Model parameters"],"type":"node"}," (",{"attributes":{},"tag":"code","children":["params"],"type":"node"},") based on a pluggable ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":["Optimisers"],"type":"node"}," (",{"attributes":{},"tag":"code","children":["opt"],"type":"node"},")."],"type":"node"},{"attributes":{},"tag":"p","children":["For each datapoint ",{"attributes":{},"tag":"code","children":["d"],"type":"node"}," in ",{"attributes":{},"tag":"code","children":["data"],"type":"node"},", compute the gradient of  ",{"attributes":{},"tag":"code","children":["loss"],"type":"node"}," with",{"attributes":{},"tag":"br","children":[],"type":"node"},"respect to ",{"attributes":{},"tag":"code","children":["params"],"type":"node"}," through backpropagation and call the optimizer ",{"attributes":{},"tag":"code","children":["opt"],"type":"node"},".",{"attributes":{},"tag":"br","children":[],"type":"node"},"If ",{"attributes":{},"tag":"code","children":["d"],"type":"node"}," is a tuple of arguments to ",{"attributes":{},"tag":"code","children":["loss"],"type":"node"}," call ",{"attributes":{},"tag":"code","children":["loss(d...)"],"type":"node"},", else call ",{"attributes":{},"tag":"code","children":["loss(d)"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["To pass trainable parameters, call ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Flux.params"],"type":"node"}],"type":"node"}," with your model or just the",{"attributes":{},"tag":"br","children":[],"type":"node"},"layers you want to train, like ",{"attributes":{},"tag":"code","children":["train!(loss, params(model), ...)"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["train!(loss, params(model[1:end-2), ...)"],"type":"node"}," respectively."],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":["Callbacks"],"type":"node"}," are given with the keyword argument ",{"attributes":{},"tag":"code","children":["cb"],"type":"node"},". For example, this will print “training”",{"attributes":{},"tag":"br","children":[],"type":"node"},"every 10 seconds (using ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Flux.throttle"],"type":"node"}],"type":"node"},"):",{"attributes":{},"tag":"br","children":[],"type":"node"},{"attributes":{},"tag":"code","children":["train!(loss, params, data, opt, cb = throttle(() -> println(\"training\"), 10))"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The callback can call ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Flux.stop"],"type":"node"}],"type":"node"}," to interrupt the training loop."],"type":"node"},{"attributes":{},"tag":"p","children":["Multiple optimisers and callbacks can be passed to ",{"attributes":{},"tag":"code","children":["opt"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["cb"],"type":"node"}," as arrays."],"type":"node"}],"type":"node"}],"type":"node"}