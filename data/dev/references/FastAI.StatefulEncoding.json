{"attributes":{"kind":"abstract type","backlinks":[{"tag":"sourcefile","title":"FastAI/src/Textual/Textual.jl","docid":"sourcefiles/FastAI/src/Textual/Textual.jl"},{"tag":"sourcefile","title":"FastAI/src/Vision/encodings/projective.jl","docid":"sourcefiles/FastAI/src/Vision/encodings/projective.jl"},{"tag":"sourcefile","title":"FastAI/src/Tabular/Tabular.jl","docid":"sourcefiles/FastAI/src/Tabular/Tabular.jl"},{"tag":"sourcefile","title":"FastAI/src/encodings/only.jl","docid":"sourcefiles/FastAI/src/encodings/only.jl"},{"tag":"sourcefile","title":"FastAI/src/Vision/Vision.jl","docid":"sourcefiles/FastAI/src/Vision/Vision.jl"},{"tag":"sourcefile","title":"FastAI/src/datablock/encoding.jl","docid":"sourcefiles/FastAI/src/datablock/encoding.jl"}],"methods":[],"name":"StatefulEncoding","title":"StatefulEncoding","symbol_id":"FastAI.StatefulEncoding","public":false,"module_id":"FastAI"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["abstract type StatefulEncoding <: Encoding\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Encoding that needs to compute some state from the whole sample, even",{"attributes":{},"tag":"br","children":[],"type":"node"},"if it only transforms some of the blocks. This could be random state",{"attributes":{},"tag":"br","children":[],"type":"node"},"for stochastic augmentations that needs to be the same for every block",{"attributes":{},"tag":"br","children":[],"type":"node"},"that is encoded."],"type":"node"},{"attributes":{},"tag":"p","children":["The state is created by calling ",{"attributes":{},"tag":"code","children":["encodestate(encoding, context, blocks, sample)"],"type":"node"},{"attributes":{},"tag":"br","children":[],"type":"node"},"and passed to recursive calls with the keyword argument ",{"attributes":{},"tag":"code","children":["state"],"type":"node"},".",{"attributes":{},"tag":"br","children":[],"type":"node"},"As a result, you need to implement ",{"attributes":{},"tag":"code","children":["encode"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["decode"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["encode!"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["decode!"],"type":"node"}," with a",{"attributes":{},"tag":"br","children":[],"type":"node"},"keyword argument ",{"attributes":{},"tag":"code","children":["state"],"type":"node"}," that defaults to the above call."],"type":"node"},{"attributes":{},"tag":"p","children":["Same goes for ",{"attributes":{},"tag":"code","children":["decode"],"type":"node"},", which should accept a ",{"attributes":{},"tag":"code","children":["state"],"type":"node"}," keyword argument defaulting",{"attributes":{},"tag":"br","children":[],"type":"node"},"to ",{"attributes":{},"tag":"code","children":["decodestate(encoding, context, blocks, sample)"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}