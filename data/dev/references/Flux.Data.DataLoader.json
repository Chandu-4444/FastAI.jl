{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"Flux/src/data/dataloader.jl","docid":"sourcefiles/Flux/src/data/dataloader.jl"},{"tag":"document","title":"Variational autoencoders","docid":"documents/notebooks/vae.ipynb"},{"tag":"documentation","title":"taskdataloaders","docid":"references/FastAI.taskdataloaders"},{"tag":"sourcefile","title":"FastAI/src/tasks/taskdata.jl","docid":"sourcefiles/FastAI/src/tasks/taskdata.jl"},{"tag":"sourcefile","title":"Flux/src/data/Data.jl","docid":"sourcefiles/Flux/src/data/Data.jl"},{"tag":"document","title":"Siamese image similarity","docid":"documents/notebooks/siamese.ipynb"},{"tag":"document","title":"fastai API comparison","docid":"documents/docs/fastai_api_comparison.md"}],"methods":[{"line":77,"file":"/home/runner/.julia/packages/Flux/7nTyc/src/data/dataloader.jl","method_id":"Flux.Data.DataLoader_1","symbol_id":"Flux.Data.DataLoader","signature":"Flux.Data.DataLoader(data; batchsize, shuffle, partial, rng)"},{"line":5,"file":"/home/runner/.julia/packages/Flux/7nTyc/src/data/dataloader.jl","method_id":"Flux.Data.DataLoader_2","symbol_id":"Flux.Data.DataLoader","signature":"Flux.Data.DataLoader(data::D, batchsize::Int64, nobs::Int64, partial::Bool, imax::Int64, indices::Vector{Int64}, shuffle::Bool, rng::R)"}],"name":"DataLoader","title":"DataLoader","symbol_id":"Flux.Data.DataLoader","public":true,"module_id":"Flux.Data"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Flux.DataLoader(data; batchsize=1, shuffle=false, partial=true, rng=GLOBAL_RNG)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["An object that iterates over mini-batches of ",{"attributes":{},"tag":"code","children":["data"],"type":"node"},",",{"attributes":{},"tag":"br","children":[],"type":"node"},"each mini-batch containing ",{"attributes":{},"tag":"code","children":["batchsize"],"type":"node"}," observations",{"attributes":{},"tag":"br","children":[],"type":"node"},"(except possibly the last one)."],"type":"node"},{"attributes":{},"tag":"p","children":["Takes as input a single data tensor, or a tuple (or a named tuple) of tensors.",{"attributes":{},"tag":"br","children":[],"type":"node"},"The last dimension in each tensor is the observation dimension, i.e. the one",{"attributes":{},"tag":"br","children":[],"type":"node"},"divided into mini-batches."],"type":"node"},{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["shuffle=true"],"type":"node"},", it shuffles the observations each time iterations are re-started.",{"attributes":{},"tag":"br","children":[],"type":"node"},"If ",{"attributes":{},"tag":"code","children":["partial=false"],"type":"node"}," and the number of observations is not divisible by the batchsize,",{"attributes":{},"tag":"br","children":[],"type":"node"},"then the last mini-batch is dropped."],"type":"node"},{"attributes":{},"tag":"p","children":["The original data is preserved in the ",{"attributes":{},"tag":"code","children":["data"],"type":"node"}," field of the DataLoader."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> Xtrain = rand(10, 100);\n\njulia> array_loader = Flux.DataLoader(Xtrain, batchsize=2);\n\njulia> for x in array_loader\n         @assert size(x) == (10, 2)\n         # do something with x, 50 times\n       end\n\njulia> array_loader.data === Xtrain\ntrue\n\njulia> tuple_loader = Flux.DataLoader((Xtrain,), batchsize=2);  # similar, but yielding 1-element tuples\n\njulia> for x in tuple_loader\n         @assert x isa Tuple{Matrix}\n         @assert size(x[1]) == (10, 2)\n       end\n\njulia> Ytrain = rand('a':'z', 100);  # now make a DataLoader yielding 2-element named tuples\n\njulia> train_loader = Flux.DataLoader((data=Xtrain, label=Ytrain), batchsize=5, shuffle=true);\n\njulia> for epoch in 1:100\n         for (x, y) in train_loader  # access via tuple destructuring\n           @assert size(x) == (10, 5)\n           @assert size(y) == (5,)\n           # loss += f(x, y) # etc, runs 100 * 20 times\n         end\n       end\n\njulia> first(train_loader).label isa Vector{Char}  # access via property name\ntrue\n\njulia> first(train_loader).label == Ytrain[1:5]  # because of shuffle=true\nfalse\n\njulia> foreach(println∘summary, Flux.DataLoader(rand(Int8, 10, 64), batchsize=30))  # partial=false would omit last\n10×30 Matrix{Int8}\n10×30 Matrix{Int8}\n10×4 Matrix{Int8}\n"],"type":"node"}],"type":"node"}],"type":"node"}